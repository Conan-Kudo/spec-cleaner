#!/usr/bin/ruby
#
# Copyright (c) 2009-2011, SUSE
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#  * Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#  * Neither the name of the <ORGANIZATION> nor the names of its contributors
#    may be used to endorse or promote products derived from this software
#    without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
#
# (Licensed under the simplified BSD license)
#
# Authors:
#   Pavol Rusnak <prusnak@opensuse.org>
#

class String
  attr_reader :_meta_
  def annotate!(meta)
    @_meta_ = meta unless meta.empty?
    self
  end
end


class Section < Array

  @program = nil

  def program=(p)
    @program = p
  end

  def program
    @program.nil? ? '' : ' -p ' + @program
  end

end


class Package

  attr_accessor :name, :version, :release, :group, :license, :url
  attr_accessor :summary, :description
  attr_accessor :sources, :patches
  attr_accessor :files, :files_include, :buildarch
  attr_accessor :buildrequires, :requires, :requires_pre, :requires_preun, :requires_post, :requires_postun, :recommends, :suggests, :supplements
  attr_accessor :provides, :obsoletes, :conflicts
  attr_accessor :pretrans, :pre, :post, :triggerin, :triggerun, :preun, :postun, :triggerpostin, :triggerpostun, :posttrans, :verifyscript

  def initialize
    @name = nil
    @version = nil
    @release = nil
    @group = nil
    @license = nil
    @url = nil
    @summary = nil
    @description = []
    @sources = {}
    @patches = {}
    @files = []
    @files_include = []
    @buildarch = nil
    @buildrequires = []
    @requires = []
    @recommends = []
    @suggests = []
    @supplements = []
    @provides = []
    @obsoletes = []
    @conflicts = []
    @requires_pre = []
    @requires_preun = []
    @requires_post = []
    @requires_postun = []
    @pretrans = nil
    @pre = nil
    @post = nil
    @preun = nil
    @postun = nil
    @posttrans = nil
    @triggerin = {}
    @triggerun = {}
    @triggerpostin = {}
    @triggerpostun = {}
    @verifyscript = nil
  end

end


class Spec

  def initialize
    @intro = []
    @packages = {}
    @prep = nil
    @build = nil
    @install = nil
    @check = nil
    @clean = nil
    @changelog = nil
    @lines = nil
    @packages = {}
  end

  def next_section(line)
    case line
      when /^%package/, /^%description/, /^%prep/, /^%build/, /^%install/, /^%check/, /^%clean/, /^%changelog/,
           /^%pretrans/, /^%pre/, /^%post/, /^%preun/, /^%postun/, /^%posttrans/,
           /^%triggerin/, /^%triggerun/, /^%triggerpostin/, /^%triggerpostun/,
           /^%verifyscript/, /^%files/
        true
     else
       false
    end
  end

  def parse_package(pkg)
    meta = []
    @packages[pkg] ||= Package.new
    loop do
      break if @lines.empty?
      line = @lines.shift
      if next_section(line)
        @lines.unshift(line)
        return
      end
      case line
        when /^$/, /^#/, /^%/
          meta << line
        when /^Name:/i
          @packages[pkg].name = line[5..-1].strip.annotate!(meta)
          meta = []
        when /^Version:/i
          @packages[pkg].version = line[8..-1].strip.annotate!(meta)
          meta = []
        when /^Release:/i
          @packages[pkg].release = line[8..-1].strip.annotate!(meta)
          meta = []
        when /^Group:/i
          @packages[pkg].group = line[6..-1].strip.annotate!(meta)
          meta = []
        when /^License:/i
          @packages[pkg].license = line[8..-1].strip.annotate!(meta)
          meta = []
        when /^Url:/i
          @packages[pkg].url = line[4..-1].strip.annotate!(meta)
          meta = []
        when /^Summary:/i
          @packages[pkg].summary = line[8..-1].strip.annotate!(meta)
          meta = []
        when /^Source:/i
          @packages[pkg].sources[0] = line[7..-1].strip.annotate!(meta)
          meta = []
        when /^Patch:/i
          @packages[pkg].patches[0] = line[6..-1].strip.annotate!(meta)
          meta = []
        when /^Source(\d+):/i
          @packages[pkg].sources[ $1.to_i ] = line.gsub(/^Source(\d+):/i, '').strip.annotate!(meta)
          meta = []
        when /^Patch(\d+):/i
          @packages[pkg].patches[ $1.to_i ] = line.gsub(/^Patch(\d+):/i, '').strip.annotate!(meta)
          meta = []
        when /^BuildArch:/i
          @packages[pkg].buildarch = line[14..-1].strip.annotate!(meta)
          meta = []
        when /^BuildRequires:/i
          @packages[pkg].buildrequires << line[14..-1].strip.annotate!(meta)
          meta = []
        when /^Requires:/i
          @packages[pkg].requires << line[9..-1].strip.annotate!(meta)
          meta = []
        when /^PreReq:/i
          @packages[pkg].requires_pre << line[7..-1].strip.annotate!(meta)
          meta = []
        when /^Requires\(pre\):/i
          @packages[pkg].requires_pre << line[14..-1].strip.annotate!(meta)
          meta = []
        when /^Requires\(preun\):/i
          @packages[pkg].requires_preun << line[16..-1].strip.annotate!(meta)
          meta = []
        when /^Requires\(post\):/i
          @packages[pkg].requires_post << line[15..-1].strip.annotate!(meta)
          meta = []
        when /^Requires\(postun\):/i
          @packages[pkg].requires_postun << line[17..-1].strip.annotate!(meta)
          meta = []
        when /^Recommends:/i
          @packages[pkg].recommends << line[11..-1].strip.annotate!(meta)
          meta = []
        when /^Suggests:/i
          @packages[pkg].suggests << line[9..-1].strip.annotate!(meta)
          meta = []
        when /^Supplements:/i
          @packages[pkg].supplements << line[12..-1].strip.annotate!(meta)
          meta = []
        when /^Provides:/i
          @packages[pkg].provides << line[9..-1].strip.annotate!(meta)
          meta = []
        when /^Obsoletes:/i
          @packages[pkg].obsoletes << line[10..-1].strip.annotate!(meta)
          meta = []
        when /^Conflicts:/i
          @packages[pkg].conflicts << line[10..-1].strip.annotate!(meta)
          meta = []
      end
    end
  end

  def parse_section
    section = Section.new
    loop do
      break if @lines.empty?
      line = @lines.shift
      if next_section(line)
        @lines.unshift(line)
        break
      end
      section << line
    end
    section.shift while not section.first.nil? and section.first.empty?
    section.pop while not section.first.nil? and section.last.empty?
    section
  end

  def parse_files_section(line)
    case line
      when /^%files\s+-n\s+(\S+)\s+-f(.*)$/
        @packages['-n ' + $1].instance_variable_set('@files', parse_section())
        @packages['-n ' + $1].instance_variable_set('@files_include', $2.split(/\s/).select { |x| x != '' and x != '-f' })
      when /^%files\s+(\S+)\s+-f(.*)$/
        @packages[$1].instance_variable_set('@files', parse_section())
        @packages[$1].instance_variable_set('@files_include', $2.split(/\s/).select { |x| x != '' and x != '-f' })
      when /^%files\s+-f(.*)$/
        @packages[''].instance_variable_set('@files', parse_section())
        @packages[''].instance_variable_set('@files_include', $1.split(/\s/).select { |x| x != '' and x != '-f' })
      when /^%files\s+-n\s+(\S+)$/
        @packages['-n ' + $1].instance_variable_set('@files', parse_section())
      when /^%files\s+(\S+)$/
        @packages[$1].instance_variable_set('@files', parse_section())
      when /^%files$/
        @packages[''].instance_variable_set('@files', parse_section())
    end
  end

  # checks for scriptlets that can have -n and -p parameters (%pre for example)
  def check_scriptlet(type, line)
    case line
      when /^%#{type}\s+-n\s+(\S+)\s+-p\s(.+)$/
        section = parse_section()
        section.program = $2.strip
        @packages['-n ' + $1].instance_variable_set('@'+type, section)
      when /^%#{type}\s+-n\s+(\S+)$/
        section = parse_section()
        @packages['-n ' + $1].instance_variable_set('@'+type, section)
      when /^%#{type}\s+-p\s(.+)$/
        section = parse_section()
        section.program = $1.strip
        @packages[''].instance_variable_set('@'+type, section)
      when /^%#{type}\s+(\S+)$/
        section = parse_section()
        @packages[$1].instance_variable_set('@'+type, section)
      when /^%#{type}$/
        section = parse_section()
        @packages[''].instance_variable_set('@'+type, section)
    end
  end

  # check triggers
  def check_trigger(type, line)
    case line
      when /^%trigger#{type}\s+-n\s+(\S+)\s+-p\s(.+)\s+--\s+(\.+)$/
        section = parse_section()
        section.program = $2.strip
        @packages['-n ' + $1].instance_variable_get('@trigger'+type)[$3] = section
      when /^%trigger#{type}\s+-n\s+(\S+)\s+--\s+(.+)$/
        section = parse_section()
        @packages['-n ' + $1].instance_variable_get('@trigger'+type)[$2] = section
      when /^%trigger#{type}\s+-p\s(.+)\s+--\s+(.+)$/
        section = parse_section()
        section.program = $1.strip
        @packages[''].instance_variable_get('@trigger'+type)[$2] = section
      when /^%trigger#{type}\s+(\S+)\s+--\s+(.+)$/
        section = parse_section()
        @packages[$1].instance_variable_get('@trigger'+type)[$2] = section
      when /^%trigger#{type}\s+--\s+(.+)$/
        section = parse_section()
        @packages[''].instance_variable_get('@trigger'+type)[$1] = section
    end
  end

  def parse(lines)

    @lines = lines.collect{ |x| x.rstrip }

    loop do
      break if @lines.empty?
      line = @lines.shift
      if line == '' or line =~ /^#/ or line =~ /^%/
        @intro << line
      else
        @lines.unshift(line)
        break
      end
    end

    @intro.shift while not @intro.first.nil? and @intro.first.empty?
    @intro.pop while not @intro.last.nil? and @intro.last.empty?

    parse_package('')

    until @lines.empty? do

      line = @lines.shift
      case line
        when /^%package\s+-n\s+(\S+)$/
          parse_package('-n ' + $1)
        when /^%package\s+(\S+)$/
          parse_package($1)
        when /^%description\s+-n\s+(\S+)$/
          @packages['-n ' + $1].description = parse_section()
        when /^%description\s+(\S+)$/
          @packages[$1].description = parse_section()
        when /^%description$/
          @packages[''].description = parse_section()
        when /^%prep$/
          @prep = parse_section()
        when /^%build$/
          @build = parse_section()
        when /^%install$/
          @install = parse_section()
        when /^%check$/
          @check = parse_section()
        when /^%clean$/
          @clean = parse_section()
        when /^%changelog$/
          @changelog = parse_section()
        when /^%files/
          parse_files_section(line)
      end

      check_scriptlet('pretrans', line)
      check_scriptlet('pre', line)
      check_scriptlet('post', line)
      check_scriptlet('preun', line)
      check_scriptlet('postun', line)
      check_scriptlet('posttrans', line)
      check_scriptlet('verifyscript', line)

      check_trigger('in', line)
      check_trigger('un', line)
      check_trigger('postin', line)
      check_trigger('postun', line)

    end

  end

  def process

  end


  def construct_package(id)

    out = []
    width = 16

    out << '%package ' + id unless id.empty?

    unless @packages[id].name.nil?
      out += @packages[id].name._meta_ unless @packages[id].name._meta_.nil?
      out << 'Name: '.ljust(width) + @packages[id].name
    end

    unless @packages[id].version.nil?
      out += @packages[id].version._meta_ unless @packages[id].version._meta_.nil?
      out << 'Version: '.ljust(width) + @packages[id].version
    end

    unless @packages[id].release.nil?
      out += @packages[id].release._meta_ unless @packages[id].release._meta_.nil?
      out << 'Release: '.ljust(width) + @packages[id].release
    end

    unless @packages[id].license.nil?
      out += @packages[id].license._meta_ unless @packages[id].license._meta_.nil?
      out << 'License: '.ljust(width) + @packages[id].license
    end

    unless @packages[id].summary.nil?
      out += @packages[id].summary._meta_ unless @packages[id].summary._meta_.nil?
      out << 'Summary: '.ljust(width) + @packages[id].summary
    end

    unless @packages[id].url.nil?
      out += @packages[id].url._meta_ unless @packages[id].url._meta_.nil?
      out << 'Url: '.ljust(width) + @packages[id].url
    end

    unless @packages[id].group.nil?
      out += @packages[id].group._meta_ unless @packages[id].group._meta_.nil?
      out << 'Group: '.ljust(width) + @packages[id].group
    end

    @packages[id].sources.keys.sort.each { |x|
      out += @packages[id].sources[x]._meta_ unless @packages[id].sources[x]._meta_.nil?
      if x == 0:
        out << "Source:".ljust(width) + @packages[id].sources[x]
      else
        out << "Source#{x}:".ljust(width) + @packages[id].sources[x]
      end
    }

    @packages[id].patches.keys.sort.each { |x|
      out += @packages[id].patches[x]._meta_ unless @packages[id].patches[x]._meta_.nil?
      out << "Patch#{x}:".ljust(width) + @packages[id].patches[x];
    }

    @packages[id].buildrequires.each { |x|
      out += x._meta_ unless x._meta_.nil?
      out << "BuildRequires:".ljust(width) + x
    }

    @packages[id].requires.each { |x|
      out += x._meta_ unless x._meta_.nil?
      out << "Requires:".ljust(width) + x
    }

    @packages[id].requires_pre.each { |x|
      out += x._meta_ unless x._meta_.nil?
      out << "Requires(pre):".ljust(width) + x
    }

    @packages[id].requires_preun.each { |x|
      out += x._meta_ unless x._meta_.nil?
      out << "Requires(preun):".ljust(width) + x
    }

    @packages[id].requires_post.each { |x|
      out += x._meta_ unless x._meta_.nil?
      out << "Requires(post):".ljust(width) + x
    }

    @packages[id].requires_postun.each { |x|
      out += x._meta_ unless x._meta_.nil?
      out << "Requires(postun):".ljust(width) + x
    }

    @packages[id].recommends.each { |x|
      out += x._meta_ unless x._meta_.nil?
      out << "Recommends:".ljust(width) + x
    }

    @packages[id].suggests.each { |x|
      out += x._meta_ unless x._meta_.nil?
      out << "Suggests:".ljust(width) + x
    }

    @packages[id].supplements.each { |x|
      out += x._meta_ unless x._meta_.nil?
      out << "Supplements:".ljust(width) + x
    }

    @packages[id].provides.each { |x|
      out += x._meta_ unless x._meta_.nil?
      out << "Provides:".ljust(width) + x
    }

    @packages[id].obsoletes.each { |x|
      out += x._meta_ unless x._meta_.nil?
      out << "Obsoletes:".ljust(width) + x
    }

    @packages[id].conflicts.each { |x|
      out += x._meta_ unless x._meta_.nil?
      out << "Conflicts:".ljust(width) + x
    }

    unless @packages[id].buildarch.nil?
      out += @packages[id].buildarch._meta_ unless @packages[id].buildarch._meta_.nil?
      out << 'BuildArch: '.ljust(width) + @packages[id].buildarch
    end

    out << ''
    out << '%description' + (id.empty? ? '' : ' ' + id)
    out += @packages[id].description

    out

  end

  def construct
    out = []

    out += @intro

    @packages.keys.sort.each{ |x|
      out << ''
      out += construct_package(x)
    }

    unless @prep.nil?
      out << ''
      out << '%prep'
      out += @prep
    end

    unless @build.nil?
      out << ''
      out << '%build'
      out += @build
    end

    unless @install.nil?
      out << ''
      out << '%install'
      out += @install
    end

    unless @check.nil?
      out << ''
      out << '%check'
      out += @check
    end

    unless @clean.nil?
      out << ''
      out << '%clean'
      out += @clean
    end

    @packages.keys.sort.each{ |x|

      unless @packages[x].pretrans.nil?
        out << ''
        out << '%pretrans' + (x.empty? ? '' : ' ' + x) + (@packages[x].pretrans.program)
        out += @packages[x].pretrans
      end

      unless @packages[x].pre.nil?
        out << ''
        out << '%pre' + (x.empty? ? '' : ' ' + x) + (@packages[x].pre.program)
        out += @packages[x].pre
      end

      unless @packages[x].preun.nil?
        out << ''
        out << '%preun' + (x.empty? ? '' : ' ' + x) + (@packages[x].preun.program)
        out += @packages[x].preun
      end

      unless @packages[x].post.nil?
        out << ''
        out << '%post' + (x.empty? ? '' : ' ' + x) + (@packages[x].post.program)
        out += @packages[x].post
      end

      unless @packages[x].postun.nil?
        out << ''
        out << '%postun' + (x.empty? ? '' : ' ' + x) + (@packages[x].postun.program)
        out += @packages[x].postun
      end

      unless @packages[x].posttrans.nil?
        out << ''
        out << '%posttrans' + (x.empty? ? '' : ' ' + x) + (@packages[x].posttrans.program)
        out += @packages[x].posttrans
      end

      unless @packages[x].verifyscript.nil?
        out << ''
        out << '%verifyscript' + (x.empty? ? '' : ' ' + x) + (@packages[x].verifyscript.program)
        out += @packages[x].verifyscript
      end

       @packages[x].triggerin.keys.sort.each{ |y|
        out << ''
        out << '%triggerin' + (x.empty? ? '' : ' ' + x) + (@packages[x].triggerin[y].program) + ' -- ' + y
        out += @packages[x].triggerin[y]
      }

      @packages[x].triggerun.keys.sort.each{ |y|
        out << ''
        out << '%triggerun' + (x.empty? ? '' : ' ' + x) + (@packages[x].triggerun[y].program) + ' -- ' + y
        out += @packages[x].triggerun[y]
      }

      @packages[x].triggerpostin.keys.sort.each{ |y|
        out << ''
        out << '%triggerpostin' + (x.empty? ? '' : ' ' + x) + (@packages[x].triggerpostin[y].program) + ' -- ' + y
        out += @packages[x].triggerpostin[y]
      }

      @packages[x].triggerpostun.keys.sort.each{ |y|
        out << ''
        out << '%triggerpostun' + (x.empty? ? '' : ' ' + x) + (@packages[x].triggerpostun[y].program) + ' -- ' + y
        out += @packages[x].triggerpostun[y]
      }

   }

    @packages.keys.sort.each{ |x|
      out << ''
      out << '%files' + (x.empty? ? '' : ' ' + x) + @packages[x].files_include.inject('') { |sum, y| sum + ' -f ' + y }
      out += @packages[x].files
    }

    unless @changelog.nil?
      out << ''
      out << '%changelog'
      out += @changelog
    end

    out.join("\n")
  end

end


abort 'Usage: spec-cleaner filename.spec' if ARGV.length < 1

spec = Spec.new

lines = IO.readlines(ARGV[0])
spec.parse(lines)

spec.process

puts spec.construct
