#!/usr/bin/ruby
#
# Copyright (c) 2009-2011, SUSE
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#  * Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#  * Neither the name of the <ORGANIZATION> nor the names of its contributors
#    may be used to endorse or promote products derived from this software
#    without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
#
# (Licensed under the simplified BSD license)
#
# Authors:
#   Pavol Rusnak <prusnak@opensuse.org>
#

class String
  attr_reader :_meta_
  def annotate!(meta)
    @_meta_ = meta unless meta.empty?
    self
  end
end

class Package

  attr_accessor :name, :version, :release, :group, :license, :url
  attr_accessor :summary, :description
  attr_accessor :sources, :patches
  attr_accessor :files
  attr_accessor :buildrequires, :requires_pre, :requires_preun, :requires_post, :requires_postun, :recommends, :suggests, :supplements
  attr_accessor :pretrans, :pre, :post, :triggerin, :triggerun, :preun, :postun, :triggerpostin, :triggerpostun, :posttrans, :verifyscript

  def initialize
    @name = nil
    @version = nil
    @release = nil
    @group = nil
    @license = nil
    @url = nil
    @summary = nil
    @description = []
    @sources = {}
    @patches = {}
    @files = []
    @files_include = nil
    @buildrequires = []
    @recommends = []
    @suggests = []
    @supplements = []
    @requires_pre = []
    @requires_preun = []
    @requires_post = []
    @requires_postun = []
    @pretrans = []
    @pre = []
    @post = []
    @triggerin = {}
    @triggerun = {}
    @preun = []
    @postun = []
    @triggerpostin = {}
    @triggerpostun = {}
    @posttrans = []
    @verifyscript = []
  end

end


class Spec

  def initialize
    @intro = []
    @packages = {}
    @prep = []
    @build = []
    @install = []
    @check = []
    @clean = []
    @changelog = []
    @lines = nil
    @packages = {}
  end

  def next_section(line)
    case line
      when /^%package/, /^%description/, /^%prep/, /^%build/, /^%install/, /^%check/, /^%clean/, /^%changelog/,
           /^%pretrans/, /^%pre/, /^%post/, /^%preun/, /^%postun/, /^%posttrans/,
           /^%triggerin/, /^%triggerun/, /^%triggerpostin/, /^%triggerpostun/,
           /^%verifyscript/, /^%files/
        true
     else
       false
    end
  end

  def full_name(pkg)
    @packages[''].name + '-' + pkg.strip
  end

  def parse_package(pkg)
    meta = []
    @packages[pkg] ||= Package.new
    loop do
      return if @lines.empty?
      line = @lines.shift
      if next_section(line)
        @lines.unshift(line)
        return
      end
      case line
        when /^$/, /^#/, /^%/
          meta << line
        when /^Name:/i
          @packages[pkg].name = line[5..-1].strip.annotate!(meta)
          meta = []
        when /^Version:/i
          @packages[pkg].version = line[8..-1].strip.annotate!(meta)
          meta = []
        when /^Release:/i
          @packages[pkg].release = line[8..-1].strip.annotate!(meta)
          meta = []
        when /^Group:/i
          @packages[pkg].group = line[6..-1].strip.annotate!(meta)
          meta = []
        when /^License:/i
          @packages[pkg].group = line[8..-1].strip.annotate!(meta)
          meta = []
        when /^Url:/i
          @packages[pkg].group = line[4..-1].strip.annotate!(meta)
          meta = []
        when /^Summary:/i
          @packages[pkg].summary = line[8..-1].strip.annotate!(meta)
          meta = []
        when /^Source:/i
          @packages[pkg].sources[0] = line[7..-1].strip.annotate!(meta)
          meta = []
        when /^Patch:/i
          @packages[pkg].patches[0] = line[6..-1].strip.annotate!(meta)
          meta = []
        when /^Source(\d+):/i
          @packages[pkg].sources[ $1.to_i ] = line.gsub(/^Source(\d+):/i, '').strip.annotate!(meta)
          meta = []
        when /^Patch(\d+):/i
          @packages[pkg].patches[ $1.to_i ] = line.gsub(/^Patch(\d+):/i, '').strip.annotate!(meta)
          meta = []
        when /^BuildRequires:/i
          @packages[pkg].buildrequires << line[14..-1].strip.annotate!(meta)
          meta = []
        when /^PreReq:/i
          @packages[pkg].requires_pre << line[7..-1].strip.annotate!(meta)
          meta = []
        when /^Requires(pre):/i
          @packages[pkg].requires_pre << line[14..-1].strip.annotate!(meta)
          meta = []
        when /^Requires(preun):/i
          @packages[pkg].requires_preun << line[16..-1].strip.annotate!(meta)
          meta = []
        when /^Requires(post):/i
          @packages[pkg].requires_post << line[15..-1].strip.annotate!(meta)
          meta = []
        when /^Requires(postun):/i
          @packages[pkg].requires_postun << line[17..-1].strip.annotate!(meta)
          meta = []
        when /^Recommends:/i
          @packages[pkg].recommends << line[11..-1].strip.annotate!(meta)
          meta = []
        when /^Suggests:/i
          @packages[pkg].suggests << line[9..-1].strip.annotate!(meta)
          meta = []
        when /^Supplements:/i
          @packages[pkg].supplements << line[12..-1].strip.annotate!(meta)
          meta = []
      end
    end
  end

  def parse_description(pkg)
    @packages[pkg] ||= Package.new
    loop do
      return if @lines.empty?
      line = @lines.shift
      if next_section(line)
        @lines.unshift(line)
        return
      end
      @packages[pkg].description << line
    end
  end

  def parse_section(section)
    loop do
      return if @lines.empty?
      line = @lines.shift
      if next_section(line)
        @lines.unshift(line)
        return
      end
      section << line
    end
  end

  def parse_files_section(line)
    case line
      when /^%files\s+-n\s+(\S+)\s+-f(.*)$/
        parse_section(@packages[$1].instance_variable_get('@files'))
        @packages[$1].instance_variable_set('@files_include', $2.split(/\s/).select { |x| x != '' and x != '-f' })
      when /^%files\s+(\S+)\s+-f(.*)$/
        parse_section(@packages[full_name($1)].instance_variable_get('@files'))
        @packages[full_name($1)].instance_variable_set('@files_include', $2.split(/\s/).select { |x| x != '' and x != '-f' })
      when /^%files\s+-f(.*)$/
        parse_section(@packages[''].instance_variable_get('@files'))
        @packages[''].instance_variable_set('@files_include', $1.split(/\s/).select { |x| x != '' and x != '-f' })
      when /^%files\s+-n\s+(\S+)$/
        parse_section(@packages[$1].instance_variable_get('@files'))
      when /^%files\s+(\S+)$/
        parse_section(@packages[full_name($1)].instance_variable_get('@files'))
      when /^%files$/
        parse_section(@packages[''].instance_variable_get('@files'))
    end
  end

  # checks for scriptlets that can have -n and -p parameters (%pre for example)
  def check_scriptlet(type, line)
    case line
      when /^%#{type}\s+-n\s+(\S+)\s+-p\s(.+)$/
        @packages[$1].instance_variable_get('@'+type) << $2.strip
      when /^%#{type}\s+-n\s+(\S+)$/
        parse_section(@packages[$1].instance_variable_get('@'+type))
      when /^%#{type}\s+-p\s(.+)$/
        @packages[''].instance_variable_get('@'+type) << $1.strip
      when /^%#{type}\s+(\S+)$/
        parse_section(@packages[full_name($1)].instance_variable_get('@'+type))
      when /^%#{type}$/
        parse_section(@packages[''].instance_variable_get('@'+type))
    end
  end

  def check_trigger(type, line)
    case line
      when /^%trigger#{type}\s+-n\s+(\S+)\s+-p\s(.+)\s+--\s+(\.+)$/
        @packages[$1].instance_variable_get('@trigger'+type)[$3] = [$2.strip]
      when /^%trigger#{type}\s+-n\s+(\S+)\s+--\s+(.+)$/
        @packages[$1].instance_variable_get('@trigger'+type)[$2] = []
        parse_section(@packages[$1].instance_variable_get('@trigger'+type)[$2])
      when /^%trigger#{type}\s+-p\s(.+)\s+--\s+(.+)$/
        @packages[''].instance_variable_get('@trigger'+type)[$2] = [$1.strip]
      when /^%trigger#{type}\s+(\S+)\s+--\s+(.+)$/
        @packages[full_name($1)].instance_variable_get('@trigger'+type)[$2] = []
        parse_section(@packages[full_name($1)].instance_variable_get('@trigger'+type)[$2])
      when /^%trigger#{type}\s+--\s+(.+)$/
        @packages[''].instance_variable_get('@trigger'+type)[$1] = []
        parse_section(@packages[''].instance_variable_get('@trigger'+type)[$1])
    end
  end

  def parse(lines)

    @lines = lines.collect{ |x| x.strip }

    loop do
      return if @lines.empty?
      line = @lines.shift
      if line == '' or line =~ /^#/ or line =~ /^%/
        @intro << line
      else
        @lines.unshift(line)
        break
      end
    end

    parse_package('')

    until @lines.empty? do

      line = @lines.shift
      case line
        when /^%package\s+-n\s+(\S+)$/
          parse_package($1)
        when /^%package\s+(\S+)$/
          parse_package(full_name($1))
        when /^%description\s+-n\s+(\S+)$/
          parse_description($1)
        when /^%description\s+(\S+)/
          parse_description(full_name($1))
        when /^%prep$/
          parse_section(@prep)
        when /^%build$/
          parse_section(@build)
        when /^%install$/
          parse_section(@install)
        when /^%check$/
          parse_section(@check)
        when /^%clean$/
          parse_section(@clean)
        when /^%changelog$/
          parse_section(@changelog)
        when /^%files/
          parse_files_section(line)
      end

      check_scriptlet('pretrans', line)
      check_scriptlet('pre', line)
      check_scriptlet('post', line)
      check_scriptlet('preun', line)
      check_scriptlet('postun', line)
      check_scriptlet('posttrans', line)
      check_scriptlet('verifyscript', line)

      check_trigger('in', line)
      check_trigger('un', line)
      check_trigger('postin', line)
      check_trigger('postun', line)

    end

  end

end


abort 'Usage: spec-cleaner filename.spec' if ARGV.length < 1

spec = Spec.new

lines = IO.readlines(ARGV[0])
spec.parse(lines)

puts spec.inspect
